\section{Part 4: CAN-Ethernet-Gateway on Infineon \\AURIX TC297}
\label{sec:can-gateway}

This chapter focuses on the implementation of a CAN-Ethernet gateway.

\subsection{Aim of the Practical Work}
The objective of this work is to design, implement, and validate a bidirectional gateway that transparently links a classical CAN bus to a standard Ethernet network on an Infineon AURIX TriCore evaluation board. Requirements for the gateway are:
\begin{itemize}
\item \{CAN → Ethernet\}: listen on the CAN bus, encapsulate every accepted CAN frame in an IPv4/UDP (or alternatively RAW) payload, and forward it so that any IP-based device can interpret native CAN traffic
\item \{Ethernet → CAN\}: accept UDP or RAW Ethernet frames that carry a properly formatted CAN payload, reconstruct standard CAN data frames and re-inject them onto the bus with correct arbitration timing
\end{itemize}
This compact overview frames the subsequent sections, which will give details about the hardware, concept and system architecture. 
\subsection{Hardware Overview: Infineon AURIX TC297}
% Describe the microcontroller and its relevant peripherals.
The Infineon TriCore microcontroller combines the capabilities of a microprocessor, microcontroller, and digital signal processor into one integrated platform, making it highly suited for automotive applications demanding real-time responsiveness and robust processing power.\\\\
Built around three 32-bit TriCore TC1.6P CPUs that run at up to 300 MHz, it couples up to 8 MB of ECC-protected flash with 728 kB on-chip RAM and a 128-channel DMA engine on a low-latency SRI cross-bar, so firmware can move payloads without stalling the cores. Gateway-relevant peripherals are integrated on-chip: a MultiCAN+ module with six independent CAN-FD-capable nodes and 10/100 Mbit/s Ethernet MAC that connects to an external PHY through MII or RMII. Because both engines share the same system bus, frames can be moved between CAN and Ethernet within deterministic microsecond budgets. A hardware security module, lock-step safety core, and redundant timer blocks complete the feature set required for ISO 26262 ASIL-D designs, making the TC297 a compact single-chip platform for the real-time CAN–Ethernet gateway realised in this project\cite{infineon}.
% Mehr ins Detail gehen?

\subsection{Theoretical Concept }
A bidirectional gateway has to move information between two networks that sit at different layers of the ISO/OSI model: CAN is a controller-centric field bus defined entirely at layer 2, whereas Ethernet is normally used as the physical bearer for layer-3 protocols such as IPv4. The design therefore needs an encapsulation scheme that (i) preserves every CAN frame bit-exactly, (ii) introduces only constant and minimal latency, and (iii) passes unhindered through standard switching, routing and diagnostic equipment.\\\\
% Bitte schreiben wieso UDP und nicht RAW
A classical CAN data frame carries an 11- or 29-bit identifier, a data length code (0-8 bytes in CAN 2.0, up to 64 bytes in CAN FD), the data field itself, plus bus-internal CRC and ACK bits. When the frame is moved to Ethernet only the semantic content must be preserved; the physical-layer bits are regenerated by the MULTICAN+ controller on retransmission. The project therefore serialises every CAN frame as a fixed-length record inside the UDP payload: four bytes little-endian identifier, one byte DLC, eight data bytes zero-padded, followed by one control byte whose individual bits flag extended identifiers and RTR frames. A short ASCII “magic” header (“ISO11898”) and a version byte at the start of the datagram allow a receiver to detect mis-alignment. Up to sixteen such records share one datagram, which keeps Ethernet utilisation high.\\\\

\begin{figure}[h]
    \centering
     \include{figures/UML/ethernet.tex}
    \caption{Example}
    \label{fig:ethernet}
\end{figure}

\subsection{Software Implementation}
% Explain the software design and key algorithms.
The implementation starts with configuring the necessary hardware peripherals on the TriCore board, such as CAN and Ethernet modules. This is accomplished by using an initialization routine (Listing 1).
\begin{lstlisting}[language=C, caption={Initialization of modules (Cpu0\_Main.c)}, label={lst:ini_module}]
void initModules(void)
{
    /* Disable watchdog timers for stable operation */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());

    /* Initialize status LEDs for debugging */
    initAliveLed();
    initBlinkyLed();
    initTxSuccessLed();
    initBufferFailLed();
    initRXETHLed();

    /* Initialize communication interfaces */
    initMultican();
    initEthernet();

    /* Initialize timing functions */
    initBlinkyTimer();

    /* Initialize the gateway module */
    initGateway();
}
\end{lstlisting}
This initialization function disables watchdog timers to ensure uninterrupted operation and sets up peripherals necessary for the gateway’s functionality, such as LEDs for visual debugging and status indication. It initializes the Multican and Ethernet modules, sets up timing mechanisms for periodic tasks, and prepares the gateway functionality.\\\\
The gateway logic is executed periodically within the main execution loop through the function \verb|runGateway()|. This function orchestrates the two principal operations: the first function \verb|forwardCanToEthernet()| handles translating CAN messages to Ethernet packets. The converting of CAN messages into Ethernet frames is shown in Listing 2.
\begin{lstlisting}[language=C, caption={CAN to Ethernet message translation (Gateway.c)}, label={lst:can_to_eth}]
void forwardCanToEthernet(void)
{
    IfxMultican_Message rxMsg;
    /* Get a handle to the high-level CAN message object driver */
    IfxMultican_Can_MsgObj* rxMsgObjHandle = &g_multican.canRxMsgObj;

    /* Check if the dedicated RX message object has a new message */
    if (IfxMultican_Can_MsgObj_isRxPending(rxMsgObjHandle))
    {
        Ifx_CAN_MO* rxMo = IfxMultican_MsgObj_getPointer(g_multican.can.mcan, rxMsgObjHandle->msgObjId);

        IfxMultican_Can_MsgObj_readMessage(rxMsgObjHandle, &rxMsg);

        boolean isExtended = IfxMultican_MsgObj_isExtendedFrame(rxMo);
        boolean isRtr = FALSE;

        uint8 dlc = rxMsg.lengthCode;
        uint8 udpPayload[17];

        udpPayload[0] = 0x01;
        udpPayload[1] = 1;

        udpPayload[2] = (uint8)(rxMsg.id >> 0);
        udpPayload[3] = (uint8)(rxMsg.id >> 8);
        udpPayload[4] = (uint8)(rxMsg.id >> 16);
        udpPayload[5] = (uint8)(rxMsg.id >> 24);

        udpPayload[6] = isExtended;
        udpPayload[7] = isRtr;
        udpPayload[8] = dlc;

        uint8 can_data_bytes[8];
        can_data_bytes[0] = (uint8)(rxMsg.data[0] >> 0);
        can_data_bytes[1] = (uint8)(rxMsg.data[0] >> 8);
        can_data_bytes[2] = (uint8)(rxMsg.data[0] >> 16);
        can_data_bytes[3] = (uint8)(rxMsg.data[0] >> 24);
        can_data_bytes[4] = (uint8)(rxMsg.data[1] >> 0);
        can_data_bytes[5] = (uint8)(rxMsg.data[1] >> 8);
        can_data_bytes[6] = (uint8)(rxMsg.data[1] >> 16);
        can_data_bytes[7] = (uint8)(rxMsg.data[1] >> 24);

        for (int i = 0; i < dlc; i++)
        {
            udpPayload[9 + i] = can_data_bytes[i];
        }

        sendEthernetPacket(udpPayload, 9 + dlc);

        /*
         * FIX: Manually clear the Receive Pending flag.
         * This is the crucial step to prevent the same message from being read again.
         */
        IfxMultican_Can_MsgObj_clearRxPending(rxMsgObjHandle);
    }
}
\end{lstlisting}
When a CAN message is received, this function checks for pending messages, reads the data into a structured format, and encapsulates it into a UDP packet. Metadata including the CAN identifier, message length, and payload are meticulously formatted. This encapsulation is critical for ensuring accurate data representation over Ethernet and allows diagnostic and monitoring tools to interpret the data correctly.\\\\
The implementation of the second operation \verb|forwardEthernetToCan()|, that handles translating Ethernet packets to CAN messages, is implemented as shown in Listing 3.

 
\begin{lstlisting}[language=C, caption={Ethernet to CAN message translation (Gateway.c)}, label={lst:eth_to_can}]
void forwardEthernetToCan(void)
{
    uint8 ethPayload[17];
    uint16 payloadLen = receiveEthernetPacket(ethPayload, sizeof(ethPayload));

    if (payloadLen > 0)
    {
        // Packet validation
        if (payloadLen < 9 || ethPayload[0] != 0x01) { return; }
        uint8 dlc = ethPayload[8];
        if (dlc > 8 || payloadLen < (9 + dlc)) { return; }

        // Packet parsing
        uint32 can_id = ((uint32)ethPayload[2]) | ((uint32)ethPayload[3] << 8) | ((uint32)ethPayload[4] << 16) | ((uint32)ethPayload[5] << 24);
        boolean id_type = ethPayload[6];
        boolean frame_type = ethPayload[7];

        // Use the proven high-level transmit function.
        // This will only forward standard data frames as per the TX message object's initial configuration.
        if (frame_type == 0 && id_type == FALSE)
        {
            uint32 dataLow = 0;
            uint32 dataHigh = 0;
            for (int i = 0; i < dlc; i++)
            {
                if (i < 4) { dataLow |= ((uint32)ethPayload[9 + i] << (i * 8)); }
                else { dataHigh |= ((uint32)ethPayload[9 + i] << ((i - 4) * 8)); }
            }

            // Create the CAN message with the ID and payload from the UDP packet
            IfxMultican_Message canMsg;
            IfxMultican_Message_init(&canMsg, can_id, dataLow, dataHigh, (IfxMultican_DataLengthCode)dlc);

            // Send the message using the function we know works reliably
            transmitCanMessage(&canMsg);
        }
    }
}
\end{lstlisting}
Upon receiving an Ethernet packet, this function validates the packet structure and contents, ensuring it meets specific criteria such as minimum length and identifier correctness. It then extracts the payload, reconstructs the CAN message identifier and data fields, and transmits this data over the CAN network. This detailed parsing and validation ensure that only valid data is transmitted, preventing erroneous or corrupted data from entering the CAN system.\\\\
In the implemented firmware every CAN frame is carried inside a single UDP datagram whose payload is a compact, variable-length record of 9–17 bytes. The preceding Ethernet, IPv4 and UDP headers are generated by \verb|sendEthernetPacket()| and stripped again by \verb|receiveEthernetPacket()|. On transmit \verb|forwardCanToEthernet()| fills these fields and hands the buffer to the Ethernet driver, thereby incurring a constant per-frame overhead of 9 bytes and avoiding dynamic memory allocations. On reception the reverse routine validates the synchronisation byte and DLC before reconstructing the CAN message. \\\\
In the opposite direction, CAN frames are captured, structured, and transmitted via Ethernet as UDP packets using the \verb|sendEthernetPacket| function, which handles packet construction and transmission management while ensuring data integrity and frame correctness.

 
\input{figures/UML/can.tex}
\input{figures/UML/gateway_ethtocan.tex}
\input{figures/UML/gateway_cantoeth.tex}
