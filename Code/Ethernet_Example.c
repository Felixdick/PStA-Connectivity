/**********************************************************************************************************************
 * \file Ethernet_Example.c
 * \copyright Copyright (C) Infineon Technologies AG 2024
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Ethernet_Example.h"
#include "IfxStm.h"
#include "IfxEth_PinMap.h"
#include "IfxEth_Phy_Pef7071.h"
#include <string.h>

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
App_Eth g_eth;
extern volatile boolean g_sendAliveMessage; /* Flag to be set by timer ISR */

/*********************************************************************************************************************/
/*-------------------------------------------Helper Function Prototypes----------------------------------------------*/
/*********************************************************************************************************************/
static inline uint16 swap_uint16(uint16 val);
uint16 calculate_ipv4_checksum(uint8* header);

/*********************************************************************************************************************/
/*--------------------------------------------Interrupt Service Routines---------------------------------------------*/
/*********************************************************************************************************************/
IFX_INTERRUPT(blinkyTimerIsr, 0, ISR_PRIORITY_BLINKY_TIMER);

void blinkyTimerIsr(void)
{
    static int counter = 0;
    IfxStm_increaseCompare(&MODULE_STM0, IfxStm_Comparator_1, IfxStm_getFrequency(&MODULE_STM0) / 5);
    IfxPort_togglePin(BLINKY_LED_PORT, BLINKY_LED_PIN);

    counter++;
    if (counter >= 5)
    {
        counter = 0;
        g_sendAliveMessage = TRUE;
    }
}

/*********************************************************************************************************************/
/*-----------------------------------------Function Implementations--------------------------------------------------*/
/*********************************************************************************************************************/

/**
 * \brief Swaps the byte order of a 16-bit value.
 *
 * This function is a replacement for the GCC-specific __builtin_bswap16 to ensure
 * portability with other compilers like Tasking.
 *
 * \param val The 16-bit value to swap.
 * \return The byte-swapped 16-bit value.
 */
static inline uint16 swap_uint16(uint16 val)
{
    return (val << 8) | (val >> 8);
}


void initBufferFailLed(void)
{
    IfxPort_setPinModeOutput(DEBUG_LED_PORT, DEBUG_LED_PIN, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinHigh(DEBUG_LED_PORT, DEBUG_LED_PIN);
}

/**
 * \brief Sends a generic UDP packet.
 * \param payload Pointer to the payload data.
 * \param payload_len Length of the payload data.
 */
void sendEthernetPacket(const uint8* payload_data, uint16 payload_len)
{
    uint8* tx_data = NULL;
    uint32 timeout_counter = 0;
    const uint32 max_retries = IFXETH_MAX_TX_BUFFERS * 2;

    while(tx_data == NULL)
    {
        tx_data = (uint8*)IfxEth_getTransmitBuffer(&g_eth.driver);
        if (tx_data == NULL)
        {
            IfxEth_shuffleTxDescriptor(&g_eth.driver);
            timeout_counter++;
            if (timeout_counter > max_retries)
            {
                //IfxPort_setPinLow(DEBUG_LED_PORT, DEBUG_LED_PIN);
                return;
            }
        }
    }
    //IfxPort_setPinHigh(DEBUG_LED_PORT, DEBUG_LED_PIN);

    /* Construct Ethernet Frame */
    const uint16 ipv4_header_len = 20;
    const uint16 udp_header_len = 8;
    const uint16 total_eth_payload_len = ipv4_header_len + udp_header_len + payload_len;
    const uint16 total_frame_len = 14 + total_eth_payload_len;
    const uint8 dest_mac[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; /* Broadcast */
    uint8 src_mac[] = ETH_MAC_ADDR;
    uint16 ether_type = swap_uint16(0x0800); /* IP EtherType */

    memcpy(tx_data + 0, dest_mac, 6);
    memcpy(tx_data + 6, src_mac, 6);
    memcpy(tx_data + 12, &ether_type, 2);

    /* Construct IP Header */
    uint8* ip_header = tx_data + 14;
    ip_header[0] = 0x45; ip_header[1] = 0x00; /* Version, IHL, ToS */
    uint16 total_len_be = swap_uint16(total_eth_payload_len);
    memcpy(ip_header + 2, &total_len_be, 2);
    ip_header[4] = 0x00; ip_header[5] = 0x00; ip_header[6] = 0x40; ip_header[7] = 0x00; /* ID, Flags, Frag Offset */
    ip_header[8] = 64; ip_header[9] = 17; /* TTL, Protocol (UDP) */
    ip_header[10] = 0x00; ip_header[11] = 0x00; /* Checksum placeholder */
    const uint8 board_ip[] = ETH_BOARD_IP_ADDR;
    const uint8 dest_ip[] = ETH_DEST_IP_ADDR;
    memcpy(ip_header + 12, board_ip, 4);
    memcpy(ip_header + 16, dest_ip, 4);
    uint16 ip_checksum = calculate_ipv4_checksum(ip_header);
    memcpy(ip_header + 10, &ip_checksum, 2);

    /* Construct UDP Header */
    uint8* udp_header = tx_data + 14 + ipv4_header_len;
    uint16 src_port_be = swap_uint16(ETH_SRC_PORT);
    uint16 dest_port_be = swap_uint16(ETH_DEST_PORT);
    uint16 udp_len = udp_header_len + payload_len;
    uint16 udp_len_be = swap_uint16(udp_len);
    memcpy(udp_header + 0, &src_port_be, 2);
    memcpy(udp_header + 2, &dest_port_be, 2);
    memcpy(udp_header + 4, &udp_len_be, 2);
    udp_header[6] = 0x00; udp_header[7] = 0x00; /* Checksum (optional for UDP/IPv4) */

    /* Copy Payload */
    uint8* payload = tx_data + 14 + ipv4_header_len + udp_header_len;
    memcpy(payload, payload_data, payload_len);

    /* Send packet */
    IfxEth_sendTransmitBuffer(&g_eth.driver, total_frame_len);
}

/**
 * \brief Checks for an incoming UDP packet and copies its payload.
 * \param buffer Buffer to store the received payload.
 * \param max_len Maximum size of the buffer.
 * \return Length of the received payload, or 0 if no valid packet was received.
 */
uint16 receiveEthernetPacket(uint8* buffer, uint16 max_len)
{
     /*
     * This function polls the hardware directly. If a frame has been received by the DMA,
     * IfxEth_getReceiveBuffer() will return a valid pointer to it.
     */
    uint8* rx_data = (uint8*)IfxEth_getReceiveBuffer(&g_eth.driver);

    /* A non-NULL pointer means a frame is ready to be processed. */
    if (rx_data)
    {
        /* A frame has been received, now validate it is a UDP packet for our port. */
        if ((rx_data[12] == 0x08 && rx_data[13] == 0x00) && /* Check for IP EtherType */
            (rx_data[14 + 9] == 17))                       /* Check for UDP Protocol */
        {
            uint8* ip_header = rx_data + 14;
            uint8 ip_header_len = (ip_header[0] & 0x0F) * 4;
            uint8* udp_header = ip_header + ip_header_len;
            uint16 dest_port = (udp_header[2] << 8) | udp_header[3];

            /* Check if the packet is addressed to the port we are listening on */
            if (dest_port == ETH_SRC_PORT)
            {
                IfxPort_togglePin(DEBUG_LED_PORT, DEBUG_LED_PIN);
                uint16 udp_total_len = (udp_header[4] << 8) | udp_header[5];
                uint16 payload_len = udp_total_len - 8;

                if (payload_len > 0 && payload_len <= max_len)
                {
                    uint8* payload = udp_header + 8;
                    memcpy(buffer, payload, payload_len);

                    /* IMPORTANT: Release the buffer back to the DMA for the next packet */
                    IfxEth_freeReceiveBuffer(&g_eth.driver);
                    return payload_len; /* Success! */
                }
            }
        }

        /* If we reach here, the packet was not for us or was invalid. We must free the buffer. */
        IfxEth_freeReceiveBuffer(&g_eth.driver);
    }

    return 0; /* No data was ready */
}

uint16 calculate_ipv4_checksum(uint8* header)
{
    uint32 sum = 0;
    for (int i = 0; i < 20; i += 2)
    {
        sum += (uint16)((header[i] << 8) | header[i + 1]);
    }
    while (sum >> 16)
    {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }
    return swap_uint16(~(uint16)sum);
}

void initAliveLed(void)
{
    IfxPort_setPinModeOutput(ALIVE_LED_PORT, ALIVE_LED_PIN, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinHigh(ALIVE_LED_PORT, ALIVE_LED_PIN);
}

void initBlinkyLed(void)
{
    IfxPort_setPinModeOutput(BLINKY_LED_PORT, BLINKY_LED_PIN, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinHigh(BLINKY_LED_PORT, BLINKY_LED_PIN);
}

void initTxSuccessLed(void)
{
    IfxPort_setPinModeOutput(TX_SUCCESS_LED_PORT, TX_SUCCESS_LED_PIN, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinHigh(TX_SUCCESS_LED_PORT, TX_SUCCESS_LED_PIN);
}

void initBlinkyTimer(void)
{
    IfxStm_CompareConfig stmConfig;
    IfxStm_initCompareConfig(&stmConfig);
    stmConfig.comparator = IfxStm_Comparator_1;
    stmConfig.triggerPriority = ISR_PRIORITY_BLINKY_TIMER;
    stmConfig.typeOfService = IfxSrc_Tos_cpu0;
    stmConfig.ticks = IfxStm_getFrequency(&MODULE_STM0) / 5;
    IfxStm_initCompare(&MODULE_STM0, &stmConfig);
}

void initEthernet(void)
{
    IfxEth_enableModule();
    IfxEth_Config ethConfig;
    IfxEth_initConfig(&ethConfig, &MODULE_ETH);
    const IfxEth_RmiiPins rmii_pins = {
        .txEn   = &IfxEth_TXEN_P11_6_OUT,   .txd0   = &IfxEth_TXD0_P11_3_OUT,
        .txd1   = &IfxEth_TXD1_P11_2_OUT,   .rxd0   = &IfxEth_RXD0_P11_10_IN,
        .rxd1   = &IfxEth_RXD1_P11_9_IN,    .crsDiv = &IfxEth_CRSDVA_P11_11_IN,
        .refClk = &IfxEth_REFCLK_P11_12_IN, .mdc    = &IfxEth_MDC_P21_0_OUT,
        .mdio   = &IfxEth_MDIO_P21_1_INOUT
    };
    ethConfig.rmiiPins = &rmii_pins;
    uint8 mac_address[] = ETH_MAC_ADDR;
    memcpy(ethConfig.macAddress, mac_address, 6);
    ethConfig.phyInterfaceMode = IfxEth_PhyInterfaceMode_rmii;
    ethConfig.phyInit = &IfxEth_Phy_Pef7071_init;
    ethConfig.phyLink = &IfxEth_Phy_Pef7071_link;
    ethConfig.rxDescr = &IfxEth_rxDescr;
    ethConfig.txDescr = &IfxEth_txDescr;
    ethConfig.isrPriority = 0; /* Let's keep interrupt priority 0 for polling mode in runGateway */
    ethConfig.isrProvider = IfxSrc_Tos_cpu0;
    IfxEth_init(&g_eth.driver, &ethConfig);
    IfxEth_startTransmitter(&g_eth.driver);
    IfxEth_startReceiver(&g_eth.driver);
    IfxEth_freeReceiveBuffer(&g_eth.driver);
}

void runEthernetLogic(void)
{
    static uint32 successful_sends = 0;
    if (IfxEth_Phy_Pef7071_link())
    {
        IfxPort_setPinLow(ALIVE_LED_PORT, ALIVE_LED_PIN);
        if (g_sendAliveMessage)
        {
            const char* msg = "i am alive";
            sendEthernetPacket((const uint8*)msg, (uint16)strlen(msg));
            successful_sends++;
            IfxPort_togglePin(TX_SUCCESS_LED_PORT, TX_SUCCESS_LED_PIN);
            g_sendAliveMessage = FALSE;
        }
    }
    else
    {
        IfxPort_setPinHigh(ALIVE_LED_PORT, ALIVE_LED_PIN);
    }
}
